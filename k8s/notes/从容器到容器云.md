# 1.再看容器

1. 我们不难看出，一个正在运行的 Linux 容器，其实可以被“**一分为二**”地看待：

   1. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“==容器镜像==”（Container Image），是容器的**静态视图**；
   2. 一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“==容器运行时==”（Container Runtime），是容器的**动态视图**。

   更进一步地说，作为一名开发者，我并不关心容器运行时的差异。因为，在整个“开发 - 测试 - 发布”的流程中，**真正承载着容器信息进行传递的，是容器镜像**，而不是容器运行时。

2. 这个重要假设，正是容器技术圈在 Docker 项目成功后不久，就**迅速走向了“==容器编排==”这个“上层建筑”的主要原因**：

   + 作为一家云服务商或者基础设施提供商，我只要能够将用户提交的 Docker 镜像以容器的方式运行起来，**就能成为这个非常热闹的容器生态图上的一个承载点**，从而将整个容器技术栈上的价值，沉淀在我的这个节点上。
   + 更重要的是，只要从我这个承载点向 Docker 镜像制作者和使用者方向回溯，整条路径上的各个服务节点，比如 CI/CD、监控、安全、网络、存储等等，都有我可以发挥和盈利的余地。这个逻辑，正是所有云计算提供商如此热衷于容器技术的重要原因：**通过容器镜像，它们可以和潜在用户（即，开发者）直接关联起来。**

3. 从一个开发者和单一的容器镜像，到无数开发者和庞大的容器集群，容器技术实现了从“容器”到“容器云”的飞跃，标志着它真正得到了市场和生态的认可。

   这样，**容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角**；==**而能够定义容器组织和管理规范的“容器编排”技术，则当仁不让地坐上了容器技术领域的“头把交椅”。**==



# 2.K8s

## 2.1目的

1. 首先，Kubernetes 项目**要解决的问题是什么**？

   **编排**？**调度**？**容器云**？**还是集群管理**？

   实际上，这个问题到目前为止都没有固定的答案。**因为在不同的发展阶段，Kubernetes 需要着重解决的问题是不同的。**



## 2.2架构

1. 而实际上，在定义核心功能的过程中，Kubernetes 项目正是依托着 Borg 项目的理论优势，才在短短几个月内迅速站稳了脚跟，进而确定了一个如下图所示的全局架构：

   ![img](https://wx2.sinaimg.cn/mw690/005LasY6ly1gwb2a4yyvdj30tw0q6tbl.jpg)

2. 我们可以看到，Kubernetes 项目的架构，跟它的原型项目 Borg 非常类似，都由 **Master** 和 **Node** 两种节点组成，而这两种角色分别对应着**控制节点**和**计算节点**。

   + 其中，==**控制节点，即 Master 节点**==，由三个紧密协作的独立组件组合而成，它们分别是负责 **API 服务**的` kube-apiserver`、负责调度的 `kube-scheduler`，以及负责**容器编排**的` kube-controller-manager`。整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。
   + 而**计算节点**上最核心的部分，则是一个叫作`kubelet `的组件。

3. ==kubelet==

   1. **在 Kubernetes 项目中，kubelet 主要负责同容器运行时（比如 Docker 项目）打交道**。而这个交互所依赖的，是一个称作 `CRI（Container Runtime Interface）`的远程调用接口，这个接口**定义了容器运行时的各项核心操作**，比如：启动一个容器需要的所有参数。

      具体的容器运行时，比如 Docker 项目，则一般通过 `OCI` 这个**容器运行时规范**同底层的 Linux 操作系统进行交互，即：把 CRI 请求翻译成对 Linux 操作系统的调用（操作 Linux Namespace 和 Cgroups 等）。

   2. **此外，kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互**。这个插件，是 Kubernetes 项目用来管理 GPU 等宿主机物理设备的主要组件，也是基于 Kubernetes 项目进行机器学习训练、高性能作业支持等工作必须关注的功能。

   3. 而**kubelet 的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储**。这两个插件与 kubelet 进行交互的接口，分别是` CNI（Container Networking Interface）`和 `CSI（Container Storage Interface）`。



# 3.k8s核心

## 3.1设计思想

1.  Kubernetes 项目要**着重解决的问题**，则来自于 Borg 的研究人员在论文中提到的一个非常重要的观点：

   > ==**运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方**==。

2. 容器技术出现以后，你就不难发现，**在“功能单位”的划分上，容器有着独一无二的“细粒度”优势**：毕竟<u>容器的本质，只是一个进程而已</u>。

   也就是说，只要你愿意，那些原先**拥挤在同一个虚拟机里的各个应用、组件、守护进程**，都可以<u>被分别做成镜像，然后运行在一个个专属的容器中</u>。

   它们之间互不干涉，拥有各自的资源配额，可以被调度在整个集群里的任何一台机器上。<u>而这，正是一个 PaaS 系统最理想的工作状态，也是所谓“微服务”思想得以落地的先决条件。</u>

3. 当然，如果**只**做到“**封装微服务、调度单容器**”这一层次，Docker Swarm 项目就已经绰绰有余了。如果再加上 Compose 项目，你甚至还具备了处理一些简单依赖关系的能力。

   可是，如果我们现在的需求是，要求这个项目<u>能够处理前面提到的所有类型的关系，甚至还要能够支持未来可能出现的更多种类的关系呢</u>？

4. 如果你做过架构方面的工作，就会深有感触：一旦要追求项目的**普适性**，那就一定要从**顶层开始做好设计。**

   所以，**Kubernetes 项目最主要的设计思想是，==从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。==**

   

## 3.2实现

1. Kubernetes 项目**对容器间的“访问”进行了分类**，首先总结出了一类非常常见的**“紧密交互”的关系**，即：这些应用之间需要非常频繁的交互和访问；又或者，它们会直接通过本地文件进行信息交换。

   在常规环境下，这些应用往往会被直接部署在同一台机器上，通过 Localhost 通信，通过本地磁盘目录交换文件。而在 Kubernetes 项目中，这些容器则会被划分为一个“**Pod**”，<u>Pod 里的容器共享同一个 Network Namespace、同一组数据卷，从而达到高效率交换信息的目的</u>。

   ==Pod 是 Kubernetes 项目中**最基础的一个对象**==，源自于 Google Borg 论文中一个名叫 Alloc 的设计。

2. 而对于**另外一种更为常见的需求**，比如 Web 应用与数据库之间的访问关系，Kubernetes 项目则提供了==<u>一种叫作“`Service`”的服务</u>==。

   像这样的两个应用，往往故意不部署在同一台机器上，这样即使 Web 应用所在的机器宕机了，数据库也完全不受影响。可是，我们知道，**对于一个容器来说，它的 IP 地址等信息不是固定的**，那么 Web 应用又怎么找到数据库容器的 Pod 呢？

   所以，Kubernetes 项目的做法是<u>给 Pod 绑定一个 Service 服务</u>，<u>而 Service 服务声明的 IP 地址等信息是“终生不变”的</u>。这个**Service 服务的主要作用，就是作为 Pod 的代理入口（Portal），从而代替 Pod 对外暴露一个固定的网络地址**。

   这样，<u>对于 Web 应用的 Pod 来说，它需要关心的就是数据库 Pod 的 Service 信息</u>。不难想象，**Service 后端真正代理的 Pod 的 IP 地址、端口等信息的自动更新、维护，则是 Kubernetes 项目的职责**。





像这样，围绕着容器和 Pod 不断向真实的技术场景扩展，我们就能够摸索出一幅如下所示的 Kubernetes 项目核心功能的“**全景图**”。

![img](https://wx4.sinaimg.cn/mw690/005LasY6ly1gwb7a3qc6sj31810metbq.jpg)

1. 按照这幅图的线索，我们从容器这个最基础的概念出发，**首先遇到了容器间“紧密协作”关系的难题，于是就扩展到了` Pod`**；

2. 有了 Pod 之后，**我们希望能一次启动多个应用的实例，这样就需要 `Deployment `这个 Pod 的多实例管理器**；

3. 而有了这样一组相同的 Pod 后，我们又需要**通过一个固定的 IP 地址和端口以负载均衡的方式访问它，于是就有了 `Service`**。

4. 可是，如果现在两个不同 Pod 之间不仅有“访问关系”，还要求在发起时加上授权信息。最典型的例子就是 Web 应用对数据库访问时需要 Credential（数据库的用户名和密码）信息。那么，在 Kubernetes 中这样的关系又如何处理呢？

   Kubernetes 项目提供了一种叫作 `Secret` 的对象，它其实是一个保存在 Etcd 里的键值对数据。这样，你**把 Credential 信息以 `Secret` 的方式存在` Etcd `里，Kubernetes 就会在你指定的 `Pod`（比如，Web 应用的 Pod）启动时，自动把 `Secret` 里的数据以 `Volume `的方式挂载到容器里。**这样，这个 Web 应用就可以访问数据库了。

5. **除了<u>应用与应用之间的关系</u>外，<u>应用运行的形态</u>是影响“如何容器化这个应用”的第二个重要因素。**

   为此，Kubernetes 定义了新的、基于 Pod 改进后的对象。比如 **`Job`**，<u>用来描述一次性运行的 Pod（比如，大数据任务）</u>；再比如 **`DaemonSet`**，用来<u>描述每个宿主机上必须且只能运行一个副本的守护进程服务</u>；又比如 **`CronJob`**，则用于描述<u>定时任务</u>等等。

==如此种种，正是 Kubernetes 项目定义**容器间**<u>关系</u>和<u>形态</u>的主要方法。==



# 3.k8s和其他项目区别

1. 可以看到，Kubernetes 项目并没有像其他项目那样，**为每一个管理功能创建一个指令，然后在项目中实现其中的逻辑**。这种做法，的确可以解决当前的问题，但是在更多的问题来临之后，往往会力不从心。

2. 相比之下，在 Kubernetes 项目中，我们所推崇的使用方法是：

   - 首先，通过一个“**编排对象**”，比如 `Pod`、`Job`、`CronJob` 等，来描<u>述你试图管理的应用</u>；
   - 然后，再为它定义一些“**服务对象**”，比如 `Service`、`Secret`、`Horizontal Pod Autoscaler`（自动水平扩展器）等。这些对象，会<u>负责具体的平台级功能</u>。

   **这种使用方法，就是所谓的“==声明式 API==”。这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）。**

   这就是 Kubernetes **最核心的设计理念**，也是接下来我会重点剖析的关键技术点。





# 4.总结

1. 实际上，过去很多的集群管理项目（比如 Yarn、Mesos，以及 Swarm）所擅长的，都是<u>把一个容器，按照某种规则，放置在某个最佳节点上运行起来</u>。这种功能，我们称为“**调度**”。

2. 而 Kubernetes 项目所擅长的，是<u>按照用户的意愿和整个系统的规则，完全自动化地处理好容器之间的各种关系</u>。**这种功能，就是我们经常听到的一个概念：编排。**

3. 所以说，Kubernetes 项目的**本质**，是==为用户提供一个具有普遍意义的<u>容器编排工具</u>==。

   不过，更重要的是，Kubernetes 项目为用户提供的不仅限于一个工具。它真正的价值，乃在于==提供了一套<u>基于容器构建分布式系统的基础依赖</u>==。