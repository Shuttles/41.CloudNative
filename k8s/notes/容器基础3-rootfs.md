# 1.前言

1. 而正如我前面所说的，Namespace 的作用是“**隔离**”，它让应用进程只能看到该 Namespace 内的“世界”；

   而 Cgroups 的作用是“**限制**”，它给这个“世界”围上了一圈看不见的墙。

   这么一折腾，进程就真的被“装”在了一个与世隔绝的房间里，而这些房间就是 PaaS 项目赖以生存的应用“沙盒”（容器）。

2. 这个房间四周虽然有了墙，但是如果容器进程低头一看地面，又是怎样一副景象呢？

   可能你立刻就能想到，这一定是一个关于 **Mount Namespace** 的问题：容器里的应用进程，==理应看到一份完全独立的文件系统==。这样，它就可以在自己的容器目录（比如 /tmp）下进行操作，而完全不会受宿主机以及其他容器的影响。

3. 事实并非如此，**即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。**



# 2.rootfs

1. 上面的问题是为什么呢？

   **Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知**。但是，这也就意味着，**只有在“挂载”这个操作发生之后，进程的视图才会被改变**。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。

   这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：**它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效**。

2. 所以，为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下**挂载一个完整操作系统的文件系统**，比如 Ubuntu16.04 的 ISO。<u>这样，在容器启动之后，我们在容器里通过执行 "ls /" 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。</u>

   **而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“==容器镜像==”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。**

   所以，一个最常见的 rootfs，或者说**容器镜像**，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等

   而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的 /bin/bash 完全不同。

3. **需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。**

   所以说，rootfs 只包括了操作系统的**“躯壳”（文件系统）**，并没有包括操作系统的**“灵魂”（内核）**。



# 3.容器的一致性

1. 由于云端与本地服务器环境不同，应用的打包过程，一直是使用 PaaS 时最“痛苦”的一个步骤。
2. 但有了容器之后，更准确地说，有了容器镜像（即 rootfs）之后，这个问题被非常优雅地解决了。
3. **由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。**
4. **这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。**



# 4.Docker的改进（==不是很懂==）

1. 为了便于维护和能够复用已有的基础容器镜像，Docker 公司做了个小创新，将 rootfs 变成了**增量** **rootfs**。
2. 这样，用户只需要**维护相对于基础镜像修改的增量内容**，所以一层的地下室变成了多层地下室，每一层都包含着应用所需要的一部分文件。
3. （原来是一个大地下室，如果出问题了，需要维修整个地下室。但是现在把大地下室拆分成了多层小地下室，现在只需要维修特定的一层小地下室就可以了。）
4. **在用户制作镜像时，每一步操作，都会生成一个层，也就是一个增量 rootfs**。



张磊原文：

1. 而在 rootfs 的基础上，Docker 公司创新性地提出了使用多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念。

2. 通过“分层镜像”的设计，以 Docker 镜像为核心，来自不同公司、不同团队的技术人员被紧密地联系在了一起。

   而且，由于容器镜像的操作是**增量式**的，这样每次镜像拉取、推送的内容，**比原本多个完整的操作系统的大小要小得多**；

   而**共享层的存在**，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。这样就使得基于容器镜像的团队协作，要比基于动则几个 GB 的虚拟机磁盘镜像的协作要敏捷得多。





# 5.Linux容器本质

1. 现在，你应该可以理解，对 ==Docker== 项目来说，它最核心的原理实际上就是为**待创建的用户进程**：
   1. 启用`Linuc Namespace`配置 -- ==隔离==
   2. 设置制定的`Cgroups`参数 -- ==限制==
   3. 切换进程的根目录（Change Root）-- ==镜像==
2. 这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。这两个系统调用虽然功能类似，但是也有细微的区别，