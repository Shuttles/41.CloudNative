

1. 在上一篇文章中，我和你详细分享了使用 StatefulSet 编排“有状态应用”的过程。从中不难看出，**StatefulSet** 其实==就是对现有典型运维业务的容器化抽象==。
2. 也就是说，你**一定有方法**在不使用 Kubernetes、甚至不使用容器的情况下，自己 DIY 一个类似的方案出来。但是，**一旦涉及到升级、版本管理等更工程化的能力，Kubernetes 的好处，才会更加凸现。**





# 1.DaemonSet

1. 顾名思义，DaemonSet 的主要作用，是让你在 Kubernetes 集群里，运行一个 **Daemon Pod**。 所以，这个 Pod 有如下三个特征：

   1. 这个 Pod 运行在 Kubernetes 集群里的**每一个节点**（Node）上；
   2. **每个节点上只有一个**这样的 Pod 实例；
   3. 当有新的节点加入 Kubernetes 集群后，该 Pod 会**自动**地在新节点上被创建出来；而当旧节点被删除后，它上面的 Pod 也相应地会被回收掉。

2. 这个机制听起来很简单，**但 Daemon Pod 的意义确实是非常重要**的。我随便给你列举几个例子：

   1. 各种**网络插件的 Agent 组件**，都必须运行在每一个节点上，用来处理这个节点上的容器网络；
   2. 各种**存储插件的 Agent 组件**，也必须运行在每一个节点上，用来在这个节点上挂载远程存储目录，操作容器的 Volume 目录；
   3. 各种**监控组件和日志组件**，也必须运行在每一个节点上，负责这个节点上的监控信息和日志搜集。

   **<u>更重要的是，跟其他编排对象不一样，DaemonSet 开始运行的时机，很多时候比整个 Kubernetes 集群出现的时机都要早。</u>**





# 总结

1. 在今天这篇文章中，我首先简单介绍了 StatefulSet 的“滚动更新”，然后重点讲解了本专栏的第三个重要编排对象：**DaemonSet。**

2. 相比于 Deployment，**DaemonSet 只管理 Pod 对象，然后通过 nodeAffinity 和 Toleration 这两个调度器的小功能，保证了每个节点上有且只有一个 Pod。**这个控制器的实现原理简单易懂，希望你能够快速掌握。

3. 与此同时，DaemonSet 使用 ControllerRevision，来保存和管理自己对应的“版本”。这种“**面向 API 对象**”的设计思路，**大大简化了控制器本身的逻辑**，也正是 Kubernetes 项目“声明式 API”的优势所在。

4. 而且，相信聪明的你此时已经想到了，StatefulSet 也是直接控制 Pod 对象的，那么它是不是也在使用 ControllerRevision 进行版本管理呢？

   没错。在 Kubernetes 项目里，**<u>ControllerRevision 其实是一个通用的版本管理对象</u>**。这样，Kubernetes 项目就巧妙地避免了每种控制器都要维护一套冗余的代码和逻辑的问题。